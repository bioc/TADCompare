---
title: "SpectralTAD Vignette"
author:
- name: Kellen Cresswell
  affiliation:
  - &1 Department of Biostatistics, Virginia Commonwealth University, Richmond, VA
- name: Mikhail Dozmorov
  affiliation:
  - *1

date: '`r format(Sys.Date(), "%B %e, %Y")`'
abstract: >
    TADCompare is an R package designed for identification and analysis of
    differential Topoloigcally Associated Domains (TADs) across multiple
    datasets. It uses a novel metric called boundary score that identifies
    the likelihood of TAD boundaries and can be used to quantify difference
    in TAD boundaries across datasets. We provide three unique functions:
    TADCompare for differential TAD boundary identification, TimeCompare
    for quantification of change over time and ConsensusTADs for consensus
    TAD calling. 
package: TADCompare
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{TADCompare}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
editor_options:
    chunk_output_type: console
bibliography: pack_ref.bib
---

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```

# Introduction

`TADCompare` is an R package for analysis of differential TAD boundaries. It is designed to work on a wide-range of HiC data. `TADCompare` contains three functions: `TADCompare`, `TimeCompare` and `ConsensusTADs`. `TADCompare` allows for identification of differential TAD boundaries between two contact matrices. `TimeCompare` takes a list of contact matrices, identifies TAD boundaries and classifies how they change over time. `ConsensusTADs` takes a list of TADs and identifies a consensus of TAD boundaries across all matrices using our novel consensus boundary score. All three functions can take matrices in n x n, sparse 3-column or n x n+3 form. None of the functions have required parameters but instructions on how to alter them are provided. 

# Getting Started

## Installation

```{r, eval = FALSE, message=FALSE}
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("TADCompare")
devtools::install_github("cresswellkg/TADCompare")
library(TADCompare)
```

## Input data

### Working with $n \times n$ matrices

$n \times n$ contact matrices, are most commonly associated with data coming from the Bing Ren lab (http://chromosome.sdsc.edu/mouse/hi-c/download.html). These contact matrices are square and symmetric with entry $ij$ corresponding to the number of contacts between region $i$ and region $j$. Below is an example of a $5 \times 5$ region of an $n \times n$ contact matrix. Derived from [@Rao:2014aa], chromosome 22 data at 50kb resolution. Note the symmetry around the diagonal - the typical shape of chromatin interaction matrix.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
data("rao_chr22_prim")
row.names(rao_chr22_prim) = colnames(rao_chr22_prim) = format(as.numeric(row.names(rao_chr22_prim)), scientific = FALSE)
rao_chr22_prim[25:30, 25:30]
```

### Working with $n \times (n+3)$ matrices

$n \times (n+3)$ matrices are commonly associated with the TopDom tad-caller (http://zhoulab.usc.edu/TopDom/). These matrices consist of a normal $n \times n$ matrix but with 3 additional leading columns containg the chromosome, the start of the region and the end of the region. Regions in this case are determined by the resolution of the data. The typical $n \times (n+3)$ matrix is shown below.

```{r, echo = FALSE, warning = FALSE}
data("rao_chr22_prim")
row.names(rao_chr22_prim) = NULL
sub_mat = cbind.data.frame("chr22", as.numeric(colnames(rao_chr22_prim)), as.numeric(colnames(rao_chr22_prim))+50000, rao_chr22_prim)[1:10, 1:10]
colnames(sub_mat) = NULL

sub_mat
```

### Working with sparse 3-column matrices

Sparse 3-column matrices, sometimes referred to as a coordinated lists, are matrices where the first and second column refer to region $i$ and region $j$ of the chromosome, and the third column is the number of contacts between them. This style is becoming increasingly popular and is associated with raw data from Rao (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE63525), and is the data output produced by the Juicer tool [@Durand:2016aa]. 3-column matrices are handled internally in the package by converting them to $n \times n$ matrices using the `HiCcompare` package's `sparse2full()` function. The first 5 rows of a typical sparse 3-column matrix is shown below.

```{r, echo = FALSE, warning = FALSE}
data("rao_chr22_prim")
head(rao_chr22_prim)
```

### Working with other data types

Users can also find TADs from data output by `cooler` (http://cooler.readthedocs.io/en/latest/index.html) and HiC-Pro (https://github.com/nservant/HiC-Pro) with minor pre-processing using the `HiCcompare` package. 

#### Working with .cool files

The cooler software can be downloaded from http://cooler.readthedocs.io/en/latest/index.html. It essentially provides access to a catalog of popular HiC datasets. We can pre-process and use .cool files that are associated with cooler files using the following steps:

1. Download `.cool` file from (ftp://cooler.csail.mit.edu/coolers)
2. Convert first matrix to text file using `cooler dump --join ftp://cooler.csail.mit.edu/coolers/hg19/Zuin2014-HEK293CtcfControl-HindIII-allreps-filtered.50kb.cool > Zuin.HEK293.50kb.Control.txt`
3. Convert first matrix to text file using `cooler dump --join ftp://cooler.csail.mit.edu/coolers/hg19/Zuin2014-HEK293CtcfDepleted-HindIII-allreps-filtered.50kb.cool > Zuin.HEK293.50kb.Depleted.txt`
4. Run the code below

```{r, eval = FALSE}
#Read in data
cool_mat1 = read.table("Zuin.HEK293.50kb.Control.txt")
cool_mat2 = read.table("Zuin.HEK293.50kb.Depleted.txt")

#Convert to sparse 3-column matrix using cooler2sparse from HiCcompare
sparse_mat1 = HiCcompare::cooler2sparse(cool_mat1)
sparse_mat2 = HiCcompare::cooler2sparse(cool_mat2)

#Run TADCompare
diff_tads = lapply(names(sparse_mat1), function(x) {
  TADCompare(sparse_mat1[[x]], sparse_mat2[[x]], resolution = 50000)
})

```

#### Working with HiC-Pro files

HiC-Pro data comes with 2 files, the `.matrix` file and the `.bed` file. The `.matrix` file is a 3-column matrix where instead of coordinates as the 1st and 2nd column, there is an ID. The `.bed` file maps these IDs to genomic coordinates. The steps for analyzing these files is shown below:

```{r, eval = FALSE}
#Read in both files
mat1 = read.table("amyg_100000.matrix")
bed1 = read.table("amyg_100000_abs.bed")

#Matrix 2

mat2 = read.table("dplfc_100000.matrix")
bed2 = read.table("dplfc_100000_abs.bed")

#Convert to modified bed format
sparse_mats1 = HiCcompare::hicpro2bedpe(mat1,bed1)
sparse_mats2 = HiCcompare::hicpro2bedpe(mat2,bed2)

#Remove empty matrices if necessary
#sparse_mats$cis = sparse_mats$cis[sapply(sparse_mats, nrow) != 0]


#Go through all pairwise chromosomes and run TADCompare
sparse_tads = lapply(1:length(sparse_mats1$cis), function(z) {
  x = sparse_mats1$cis[[z]]
  y = sparse_mats2$cis[[z]]
  
  #Pull out chromosome
  chr = x[,1][1]
  #Subset to make three column matrix
  x = x[,c(2,5,7)]
  y = y[,c(2,5,7)]
  #Run SpectralTAD
  comp = TADCompare(x,y, resolution = 100000)
  return(list(comp, chr))
})

#Pull out differential TAD results
diff_res = lapply(sparse_tads, function(x) x$comp)
#Pull out chromosomes
chr = lapply(sparse_tads, function(x) x$chr)
#Name list by corresponding chr
names(diff_res) = chr
```

## Running TADcompare

The only required input is two contact matrices. TADCompare will automatically determine the type of matrix and convert it to an appropriate form, given it is one of the supported formats. The only requirement is that all matrices be in the same format. For fastests results, we suggest using n x n matrices. Additionally, we suggest users input the resolution of their data. If resolution is not inputted we estimate it using the column names of the inputted contact matrix. 

```{r, message = FALSE, warning = FALSE}
#Get the rao contact matrices built into the package
data("rao_chr22_prim")
data("rao_chr22_rep")
#We see these are n x n matrices
dim(rao_chr22_prim)
dim(rao_chr22_rep)
#Running the algorithm with resolution specified
results = TADCompare(rao_chr22_prim, rao_chr22_rep, resolution = 50000)
#Printing the first 5 differential boundaries
head(results$Diff_Loci, 5)
#Repeating without specifying resolution
no_res = TADCompare(rao_chr22_prim, rao_chr22_rep)
#We can see below that resolution can be estimated automatically if necessary
identical(results$Diff_Loci, no_res$Diff_Loci)
```

## Running MultiCompare

`TimeCompare` takes a list of matrices similar in format to `TADCompare`. Like `TADCompare`, `TimeCompare` will estimate resolution and convert matrices to the appropriate format. For this example we use time-varying contact matrices from [@Rao:2017aa]. The matrices represent a single 50kb resolution contact matrix treated with chromatin destroying Auxin at 4 time points, starting with application and charting the withdrawal process.

```{r, message = FALSE, warning = FALSE}
#Get the list of contact matrices
data("time_mats")
#Checking format
head(time_mats[[1]])
#These are sparse 3-column matrices

#Running MultiCompare
time_var = TimeCompare(cont_mats, resolution = 50000)

```

## Removing gaps

Though, it has been shown that windowed spectral clustering is more robust to sparsity than other common methods[@cresswell:2019aa], there is still some instability caused by consecutive regions of gaps. To counter this, we use a `gap_threshold` parameter to allow users to exclude regions based on how many zeros are included. By default this value is set to 1 which means only columns/rows with 100% of values being zero are removed before analysis. Accordingly, setting this value to .7 would mean rows/columns with 70% zeros would be removed. Since we are not interested in long-range contacts for TAD identification, this percentage only applies to the number of zeros within a specific distance of the diagonal (Defined by the maximum TAD size). Users must be careful not to filter too much as this can remove informative regions of the matrix.

## Running SpectralTAD with parallelization

It is sometimes the case that people want to run SpectralTAD on multiple chromosomes at once in parallel. This can be done using the `SpectralTAD_Par` function. SpectralTAD_Par is identical to SpectralTAD but takes a list of contact matrices as an input. These matrices can be of any of the allowable types and mixing of types is allowed. Users are required to provide a vector of chromosomes, `chr_over`, where it is ordered such that each entry matches up with its corresponding contact matrix in the list of matrices. Users can also input list names using the `labels` parameter. In terms of parallelization, users can either input the number of cores they would like to use or the function will automatically use 1 less than the total number of cores on the computer on which it is ran. The function works on Linux/Mac and Windows with automatic OS detection built in. We show the steps below.

## Effect of matrix type on runtime

The type of matrix input into the algorithm can affect runtimes for the algorithm. $n \times n$ matrices require no conversion and are the fastest. Meanwhile, $n \times (n+3)$ matrices take slightly longer to run due to the need to remove the first 3 columns. Sparse 3-column matrices have the highest runtimes due to the complexity of converting them to an $n \times n$ matrix. The times are summarized below, holding all other parameters constant.

```{r, message = FALSE}
library(microbenchmark)
#Converting to nxn
n_n = HiCcompare::sparse2full(rao_chr20_25_rep)
#Converting to nxn+3
n_n_3 = cbind.data.frame("chr20", as.numeric(colnames(n_n)), as.numeric(colnames(n_n))+25000, n_n)
#Defining each function
sparse = SpectralTAD(cont_mat = rao_chr20_25_rep, chr = "chr20", qual_filter = FALSE)
n_by_n = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE)
n_by_n_3 =SpectralTAD(cont_mat = n_n_3, chr = "chr20", qual_filter = FALSE)

#Benchmarking different parameters
microbenchmark(sparse = SpectralTAD(cont_mat = rao_chr20_25_rep, chr = "chr20", qual_filter = FALSE),
n_by_n = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE),
n_by_n_3 =SpectralTAD(cont_mat = n_n_3, chr = "chr20", qual_filter = FALSE), unit = "s", times = 3)
```

## Effect of parameters on runtime

Just as the type of data affects runtime, the parameters used to detect TADs do as well. The main bottleneck is the quality filter function which requires the inversion of a matrix and the calculation of silhouette score.

```{r, message = FALSE}
microbenchmark(quality_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = TRUE, z_clust = FALSE), no_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = FALSE), z_clust = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = TRUE), times = 3, unit = "s")
```

As can be seen using the z-score method is the fastest.

## Using SpectralTAD output with HiCExplorer and Juicebox

SpectralTAD is designed to work in tandem with Juicebox (http://www.aidenlab.org/juicebox/) and HiCExplorer (https://hicexplorer.usegalaxy.eu/), two popular TAD visualization tools. Users may output files, corresponding to either tools.

### Using SpectralTAD with HiCExplorer

HiCExplorer takes simple bed files. To use SpectralTAD with HiCExplorer, do the following:

```{r, eval = FALSE}
#Get contact matrix
data("rao_chr20_25_rep")
head(rao_chr20_25_rep)
#Run spectral TAD with output format "hicexplorer" or "bed" and specify the path
spec_hier = SpectralTAD(rao_chr20_25_rep, chr = "chr20", resolution = 25000, qual_filter = FALSE, levels = 3, out_format = "hicexplorer", out_path = "chr20.bed")

```

This code will output a three-column bed file with TAD coordinates for all three levels. hicPlotTADs from HiCExplorer takes a .ini configuration file. To use SpectralTAD results you simply just have to set the output file as the directory under the [tads] subheading. For a full walk-through see (https://hicexplorer.readthedocs.io/en/latest/content/tools/hicPlotTADs.html#id4) under the heading "Configuration file template."

### Using SpectralTAD with Juicebox

Juicebox takes bedpe files as its primary file type. To use SpectralTAD with Juicebox, do the following:

```{r, eval = FALSE}
#Get contact matrix
data("rao_chr20_25_rep")
head(rao_chr20_25_rep)
#Run spectral TAD with output format "hicexplorer" or "bed" and specify the path
spec_hier = SpectralTAD(rao_chr20_25_rep, chr = "chr20", resolution = 25000, qual_filter = FALSE, levels = 3, out_format = "juicebox", out_path = "chr20.bedpe")
```

The output for this code is an 11-column bedpe file, which is formatted to work for Juicebox. To use the file, you must first select a HiC matrix in the Juicebox interface (https://www.aidenlab.org/juicebox/). This is done by choosing `Load Map -> Select File -> Select Contact Map`. This data corresponds to `Rao and Huntley et al. | Cell 2014 GM12878 (human) in situ ENCODE Batch 1 HIC048` so we select this. Alternatively, you can upload your own hic matrix in .hic or .cool format. To select the TADs called by `SpectralTAD` simply choose `Load Tracks -> Local Track File -> Choose File -> chr20.bedpe`. To view chromosome 20 specifically, select `≡ -> Chromosomes -> chr20`.




# References
