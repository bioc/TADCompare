---
title: "TAD comparison between two conditions"
author:
- name: Kellen Cresswell
  affiliation:
  - &1 Department of Biostatistics, Virginia Commonwealth University, Richmond, VA
- name: Mikhail Dozmorov
  affiliation:
  - *1
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{TADCompare}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
editor_options:
    chunk_output_type: console
bibliography: pack_ref.bib
---

```{r set-options, echo=FALSE, cache=FALSE}
options(stringsAsFactors = FALSE)
```

# Introduction

`TADCompare::TADCompare` is a function that allows users to automatically identify differential TAD boundaries between two datasets. For each differential boundary, we provide unique classification (complex, merge, split, shifted and strength change) defining how the TAD boundaries change between the datasets.

# Running TADcompare

The only required input is two contact matrices in one of the permitted forms specified in the [Input data vignette](Input_Data.html). TADCompare will automatically determine the type of matrix and convert it to an appropriate form, given it is one of the supported formats. The only requirement is that all matrices be in the same format. For fastests results, we suggest using $n \times n$ matrices. Additionally, we suggest users to provide resolution of their data. If resolution is not provided, we estimate it using the numeric column names of contact matrices. 

```{r, warning=FALSE,message=FALSE}
library(TADCompare)
library(dplyr)
```

```{r, message = FALSE, warning = FALSE}
#Get the rao contact matrices built into the package
data("rao_chr22_prim")
data("rao_chr22_rep")
#We see these are n x n matrices
dim(rao_chr22_prim)
dim(rao_chr22_rep)
#Running the algorithm with resolution specified
results = TADCompare(rao_chr22_prim, rao_chr22_rep, resolution = 50000)
#Repeating without specifying resolution
no_res = TADCompare(rao_chr22_prim, rao_chr22_rep)
#We can see below that resolution can be estimated automatically if necessary
identical(results$Diff_Loci, no_res$Diff_Loci)
```


## Types of TADCompare output

TADCompare returns a list with 2 data frames and 1 plot. The first data frame contains all regions of the genome containing a TAD boundary in at least one of the contact matrices. The results are shown below:

```{r}
head(results$TAD_Frame)
```

The "Boundary" column is simply a genomic coordinates of the given boundary. "Gap_Score" corresponds to the differential boundary score (Z-score of the difference between boundary scores). "TAD_Score1" and "TAD_Score2" corresponds to the boundary score of the two contact matrices. "Differential" simply indicates whether the data is differential or not differential. "Enriched_In" indicates which matrix contains the TAD boundary. "Type" identifies the category of TAD change. 

The second data frame contains the same information as the first data frame but includes every region of the genome. We show it below:

```{r}
head(results$Boundary_Scores)
```

"Region" corresponds to the region of the genome. "TAD_Score1" and "TAD_Score2" correspond to boundary scores for each contact matrix and "Gap_Score" is the differential boundary score. 


Finally, we include a plot which contains a stacked barplot indicating the prevelance of each type of TAD boundary. The barplot is created in ggplot2, making it completely customizable. We show this below:

```{r}
results$Count_Plot
```

[??? Separate into a vignette, make generic, applicable to everything]
## Performing gene ontology analysis using TADCompare

To demonstrate one of the ways to interpret the results of differential and time course TAD boundary analysis, we perform gene ontology enrichment analysis using `rGREAT` (https://bioconductor.org/packages/release/bioc/html/rGREAT.html). We first show how to perform gene ontology enrichment on shifted boundaries detected in matrix 1.

```{r, warning=FALSE, message = FALSE}
library(rGREAT)
#Saving the results into its own data frame
TAD_Frame = results$TAD_Frame
#Filter data to only include complex boundaries enriched in the first contact matrix
TAD_Frame = TAD_Frame %>% dplyr::filter( (Type == "Shifted") & (Enriched_In == "Matrix 2")  )
#Assign a chromosome and convert to a bed format
TAD_Frame = TAD_Frame %>% dplyr::select(Boundary) %>%
  mutate(chr = "chr22", start = Boundary, end = Boundary) %>% dplyr::select(chr,start,end)
#Set up rGREAT job with default parameters
great_shift = submitGreatJob(TAD_Frame, request_interval = 1, version = "2.0")
#Submit the job
enrichment_table = getEnrichmentTables(great_shift)
#Find the top p-values in GO biological processes
head(enrichment_table$`GO Biological Process` %>% dplyr::arrange(Hyper_Raw_PValue))
```

Now we demonstrate how to perform the same analysis but for all boundary types simultaneously. For this example we focus on boundaries enriched in matrix 2. 

```{r}
#Pulling out the frame of TADs
TAD_Frame = results$TAD_Frame %>% filter(Enriched_In == "Matrix 2")
#Getting sets of coordinates for TAD boundaries and converting into bed format
Bound_List = lapply(unique(TAD_Frame$Type), function(x) {
  TAD_Frame %>% filter((Type == x))  %>% mutate(chr = "chr22") %>% dplyr::select(chr, Boundary) %>%
  mutate(start = Boundary, end = Boundary) %>% dplyr::select(chr,start,end)
})
#Performing rGREAT analysis for each boundary type
TAD_Enrich = lapply(Bound_List, function(x) getEnrichmentTables(submitGreatJob(x, request_interval = 1, version = "2.0")))
#Name list of data frames to keep track of which enrichment belongs to which
names(TAD_Enrich) = unique(TAD_Frame$Type)
#Bind each type of pathway and create new column for each pathway
TAD_Enrich = lapply(names(TAD_Enrich), function(x) bind_rows(lapply(TAD_Enrich[[x]], function(y) y %>% mutate(Type = x)), .id = 'source')) 
#Bind each boundary type together
enrichment_table = bind_rows(TAD_Enrich) %>% dplyr::select(Ontology = `source`, Description = `name`, `P-value` = Hyper_Raw_PValue, Type)
#Get the top enriched pathways
head(enrichment_table %>% dplyr::arrange(`P-value`))
```

[??? If no references, delete this header from the vignette]
# References
